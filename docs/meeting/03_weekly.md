# 오픈소스 SW 기초
# 팀 프로젝트 Weekly Report - 3주차

- **프로젝트명**: NoR (Not only R)
- **팀명**: NoR 팀 (Team 7)
- **주차**: 제3주차
- **기간**: 2025.05.15 ~ 2025.05.21
- **작성자**: 최현경
- **팀원**: 최현경(32224802), 류지성(32241484), 이운길(32237627)

## 목차
1. 서론
2. 문법 설계 논의
3. 파서 및 실행기 설계
4. 그래프 렌더링 설계
5. GUI 기획 및 구성 논의
6. 구현 기록 및 논의 사항

## 1. 서론

NOR팀의 3주차(05.15 ~ 05.21)의 목표는 각자 작업을 진행하며 마주친 문제를 공유하고, 그를 바탕으로 NoR DSL 프로젝트의 언어 체계와 구현 방향을 수정 및 구체화하여 사용자 친화적인 문법과 인터페이스 기초를 마련하는 것이다. 본 주차는 DSL의 언어적 기초를 다지고, 파서 및 GUI 구현의 기반을 정립하는 데 초점을 맞추었다. 특히, 단순한 명령어 나열이 아닌 추상화 수준의 설정, 시각적 속성의 표현 방식 통일, 사용자 중심 문법 설계, 그리고 구체적인 예외 처리 방안 마련 등을 중심으로 논의가 진행되었다.

2025년 5월 16일 오후 4시에 진행된 온라인 회의에는 최현경, 이운길, 류지성이 참여하였으며, 다음과 같은 핵심 논의가 이루어졌다.

### 1. 문법 설계 기조
NoR DSL은 단순히 matplotlib 함수나 파라미터를 그대로 매핑하는 것을 지양하며, 보다 높은 수준의 의미적 추상화를 지향한다. 즉, 사용자가 직접 세부 속성을 나열하기보다, 전체 그래프의 목적과 스타일을 선언적으로 기술할 수 있도록 구성하고자 한다. 그래프를 연구 논문이나 프레젠테이션에 사용하는 실제 목적에 맞추어, 사용자 친화적이면서도 정형화된 문법 설계를 목표로 설정하였다.

### 2. 사용자 입력 구조 방향성
입력 문장은 "그래프 생성", "x축은", "그리기" 등 한글 기반 자연어 스타일의 문법을 유지하기로 했다. 명령어 예시로는 "스타일은 논문용", "축이름은 시간, 온도" 등 사용자가 직관적으로 이해할 수 있는 형태로 하기로 하였다. "스타일", "축", "데이터"와 같이 의미 있는 키워드를 중심으로 명확한 문장 구조를 유도하며, 다양한 동의 표현은 통일된 키워드로 정규화할 계획이다.

### 3. 구현 시 중점 사항
- **색상 처리**: 한글 색상명을 HEX 코드로 자동 변환하는 기능 개발 예정 ("빨간색" → #FF0000 등)
- **스타일 통합**: 마커 스타일과 선 스타일을 통합적으로 처리하고, 별도의 선언 없이도 스타일 프리셋 적용 가능하도록 구현할 예정
- **크기 및 해상도 표현 방식**: 사용자가 숫자나 픽셀 단위를 명시하지 않아도 "크게", "중간", "작게" 등의 선언으로 설정 가능하게 설계
- **스타일 프리셋**: "스타일은 프레젠테이션", "스타일은 논문용"과 같은 명령어로 전체 시각 요소를 한 번에 지정할 수 있는 기능 도입을 논의

### 4. 예외 처리 및 사용자 피드백
- 에러 메시지는 반드시 한국어로 상세하게 출력하며, 예외가 발생한 이유와 수정 방향을 안내
- 속성 누락 시 기본값 자동 지정 로직을 마련하여, 최소 입력만으로도 그래프 생성이 가능하도록 유도
- 파서 처리 단계에서 명령어 누락, 오타 등 사용자 실수에 대해 유연하게 대응할 수 있도록 사전 정의된 룰 기반 대응 체계를 구상

## 2. 문법 설계 논의

### 1) DSL 문법의 목적 및 철학
NoR의 DSL(도메인 특화 언어)은 논문이나 보고서에 적합한 고품질 그래프를 누구나 쉽게 작성할 수 있도록 설계한 언어이다. 기존의 matplotlib 기반 시각화는 명령어가 복잡하고, 시각적 속성을 일일이 설정해야 하는 어려움이 있어 진입장벽이 높다는 문제가 있었다. NoR DSL은 이러한 문제를 해결하고자 다음과 같은 철학을 바탕으로 문법을 구성하였다.

- **첫째**, 사용자가 직관적으로 명령을 입력할 수 있도록 자연어에 가까운 문법을 지향
- **둘째**, 그래프 시각화 과정의 복잡한 요소들을 추상화하여 고수준 명령어로 대체
- **셋째**, 색상, 마커, 폰트와 같은 시각적 속성은 프리셋 기반으로 자동 지정

### 2) 주요 문법 요소
NoR DSL에서 사용되는 명령어는 그래프의 구성요소에 따라 분류되며, 각 명령어는 자연어적 표현을 중심으로 설계되었다.

| 문법 유형 | 주요 키워드 / 속성 | 예시 | 설명 |
|-----------|-------------------|------|------|
| 그래프 생성 | 그래프생성 | "온도 변화" | 그래프 작성의 시작점을 선언함 |
| 그래프 그리기 | 그리기, 그려줘, draw | 없음 | 그래프를 실제로 출력하는 실행 트리거임 |
| 제목 설정 | 제목, 타이틀, title | "기온 변화" | 그래프 상단에 표시될 제목을 설정함 |
| 그래프 종류 | 종류, 유형, 타입, 그래프종류 | "선", "막대", "산점도" | 그래프의 기본 유형을 설정함 |
| 축 라벨 설정 | x축, 엑스축, xlabel | "시간" | x축에 표시할 텍스트를 지정함 |
| | y축, 와이축, ylabel | "온도" | y축에 표시할 텍스트를 지정함 |
| | 축이름, 레이블, labels | "시간", "온도" | x축과 y축 라벨을 동시에 지정함 |

### 3) 스타일 프리셋 및 색상 팔레트

#### 스타일 프리셋
사용자는 다음과 같이 스타일을 지정할 수 있으며, 내부적으로는 style_config.py에 정의된 딕셔너리 형태로 관리된다.
- 스타일은 "논문용"
- 스타일은 "프레젠테이션"
- 스타일은 "기본"

#### 색상 매핑 테이블
NoR DSL은 한글 색상명을 HEX 코드로 자동 변환하며, 다음은 주요 매핑 예시이다.

| 한글 이름 | HEX 코드 | 주요 용도 |
|-----------|----------|-----------|
| 빨강 | #FF0000 | 강조, 경고 |
| 파랑 | #1F77B4 | 기본 선 색상 |
| 초록 | #2CA02C | 자연, 안정감 표현 |
| 노랑 | #FFD700 | 주의 색상 |
| 검정 | #000000 | 텍스트, 테두리 |
| 흰색 | #FFFFFF | 배경색 |
| 회색 | #888888 | 보조선, 중립톤 표현 |
| 민트 | #AAF0D1 | 시각적 강조 |
| 핑크 | #FFC0CB | 감성적 분위기 표현 |

### 4) DSL 예시 코드
다음은 실제 DSL 문법을 활용한 입력 예시이다.

```
그래프생성 "기온 변화"
x축은 "시간"
y축은 "기온"
스타일은 "논문용"
그리기
```

이 예시는 "기온 변화"라는 제목의 선그래프를 생성하며, x축은 "시간", y축은 "기온"으로 라벨링된다. 스타일은 "논문용"으로 지정되어, 폰트, 배경, 선 색상, 마커 등이 자동으로 설정되며, 마지막 "그리기" 명령을 통해 실제 그래프가 출력된다.

## 3. 파서 및 실행기 설계

### 1) 사용 기술: Lark (Python 기반 파서 생성기)
NoR DSL의 문법 해석 및 명령 실행을 위해 Python 기반의 파서 생성기인 Lark 라이브러리를 사용하였다. Lark는 EBNF(Extended Backus-Naur Form) 또는 PEG(Parsing Expression Grammar) 문법을 기반으로 파서를 자동 생성하고, 문자열 입력을 추상 구문 트리(AST: Abstract Syntax Tree) 형태로 변환할 수 있는 도구이다.

Lark를 도입함으로써 다음과 같은 효과를 기대할 수 있다:
- 문법 구조를 정형화하여 컴파일 시점에 문법 오류를 잡을 수 있음
- .lark 파일을 통해 명확하고 가독성 있는 문법을 정의할 수 있음
- Transformer를 활용하여 AST를 사용하기 쉬운 딕셔너리 구조로 변환할 수 있음

### 2) 문법 정의 구조 (grammar.lark)
문법 구성 원칙:
- 모든 문법의 시작점(start rule)은 start로 정의
- 터미널(고정 문자열)은 대문자, 비터미널(규칙)은 소문자로 정의
- 주석(//), 공백(WS), 줄바꿈 등은 모두 무시 처리

간략한 문법 정의 예시:
```
// NoR DSL 문법
start: statement+
statement: draw_statement
| set_title_statement
| set_labels_statement
| set_style_statement
| save_statement
| axis_statement
| create_statement

create_statement: CREATE_KEYWORD STRING
draw_statement: DRAW_KEYWORD
set_title_statement: TITLE_KEYWORD STRING
set_labels_statement: X_LABEL_KEYWORD STRING
| Y_LABEL_KEYWORD STRING
set_style_statement: STYLE_KEYWORD STRING
save_statement: SAVE_KEYWORD STRING
axis_statement: AXIS_KEYWORD STRING "," STRING

// 터미널 정의
CREATE_KEYWORD: "그래프생성"
DRAW_KEYWORD: "그리기" | "그려줘" | "draw"
TITLE_KEYWORD: "제목" | "타이틀"
X_LABEL_KEYWORD: "x축" | "엑스축"
Y_LABEL_KEYWORD: "y축" | "와이축"
AXIS_KEYWORD: "축이름"
STYLE_KEYWORD: "스타일"
SAVE_KEYWORD: "저장"
STRING: DQ_STRING | SQ_STRING
DQ_STRING: /"[^"\\]*(\\.[^"\\]*)*"/
SQ_STRING: /'[^'\\]*(\\.[^'\\]*)*'/
%import common.WS
%ignore WS
```

### 3) AST 처리 흐름
DSL 스크립트가 파싱되면, Lark는 이를 AST 형태로 반환하며, Transformer 클래스를 통해 딕셔너리 기반 명령어 리스트로 변환한다. 이 구조는 이후 실행기의 입력 데이터로 사용된다.

예시: Transformer 클래스
```python
from lark import Transformer

class NorTransformer(Transformer):
    def create_statement(self, items):
        return {"명령": "그래프생성", "제목": items[0].strip('"')}
    
    def draw_statement(self, _):
        return {"명령": "그리기"}
    
    def set_title_statement(self, items):
        return {"명령": "제목", "값": items[0].strip('"')}
    
    def set_labels_statement(self, items):
        return {"명령": "x축", "값": items[0].strip('"')}
    
    def set_style_statement(self, items):
        return {"명령": "스타일", "값": items[0].strip('"')}
```

### 4) 명령 실행기 구조
AST에서 변환된 딕셔너리 명령어 리스트는 GraphExecutor 클래스에서 순차적으로 실행된다. 해당 클래스는 DSL 명령을 실제 matplotlib 기반 그래프 생성과 연결하는 핵심 실행기이다.

예시: GraphExecutor 클래스
```python
class GraphExecutor:
    def execute(self, command_list):
        for command in command_list:
            if command["명령"] == "그래프생성":
                self.init_graph(title=command["제목"])
            elif command["명령"] == "제목":
                self.set_title(command["값"])
            elif command["명령"] == "x축":
                self.set_x_label(command["값"])
            elif command["명령"] == "y축":
                self.set_y_label(command["값"])
            elif command["명령"] == "스타일":
                self.set_style(command["값"])
            elif command["명령"] == "그리기":
                self.draw()
```

### 5) 벡터 파싱 오류 해결
문제 상황:
벡터 파싱 정의가 다음과 같을 때,
```
vector: "[" [element ("," element)* ] "]"
```
줄바꿈 또는 공백으로 인해 UnexpectedToken 오류가 발생하는 문제가 있었다.

해결 방법:
벡터 구조를 빈 벡터와 비어 있지 않은 벡터로 분리 처리:
```
vector: empty_vector | non_empty_vector
empty_vector: "[" "]"
non_empty_vector: "[" elements "]"
elements: element ("," element)*
```

### 6) AST 변환 예시
입력 DSL 스크립트:
```
그래프생성 "매출 그래프"
x축은 "월"
y축은 "매출"
스타일은 "논문용"
그리기
```

변환된 AST (명령어 리스트):
```python
[
    {'명령': '그래프생성', '제목': '매출 그래프'},
    {'명령': 'x축', '값': '월'},
    {'명령': 'y축', '값': '매출'},
    {'명령': '스타일', '값': '논문용'},
    {'명령': '그리기'}
]
```

## 4. 그래프 렌더링 설계

### 1) 목표
NoR DSL에서 생성된 명령어는 내부적으로 AST(Abstract Syntax Tree)로 변환되며, 해당 AST를 기반으로 Python의 matplotlib 라이브러리를 활용하여 그래프를 시각적으로 출력하거나 이미지 파일로 저장하도록 설계되어 있다. 최종 사용자 입장에서는 NoRScript를 입력하고 실행만 하면 되며, 내부적으로는 명령의 의미를 분석하고 시각적 속성을 반영하여 그래프를 그려주는 방식으로 동작한다.

### 2) 전체 실행 흐름
NoR에서의 실행 과정은 다음과 같은 단계로 구성된다:
1. DSL 스크립트 입력
2. 파서를 통한 AST 생성
3. Transformer를 통한 명령어 리스트 변환
4. GraphExecutor를 통한 명령어 실행
5. matplotlib을 통한 그래프 렌더링
6. 결과 출력 또는 파일 저장

### 3) 핵심 클래스 설계
Graph 클래스는 그래프 렌더링을 담당하는 핵심 클래스이며, 사용자가 정의한 그래프 종류에 따라 내부적으로 적절한 함수가 호출된다. 예를 들어, DSL에서 "종류는 선"이라고 입력하면 내부적으로 "종류": "선그래프"로 변환되어 draw_line() 함수가 실행된다.

### 4) 축 설정 함수
각 축의 색상, 라벨, 눈금 위치 등은 별도의 set_axis 함수를 통해 설정된다.

### 5) 스타일 및 기본값 처리
#### 색상 변환
사용자가 한글로 색상을 입력하는 경우, 이를 HEX 코드로 변환하는 함수를 통해 내부 처리한다.
```python
convert_color("파랑") → "#1F77B4"
```

### 6) 추상화된 크기/스타일 지정
DSL에서는 숫자가 아닌 "굵기는 3"과 같이 추상적 표현을 사용할 수 있으며, 내부적으로는 선 굵기와 마커 크기로 매핑된다. 예를 들어, DSL에서 "굵기는 3"이라고 지정하면 선의 두께는 3, 마커의 크기는 6으로 자동 적용된다.

### 7) 최종 명령 실행 구조 예시
```python
{
    "종류": "선그래프",
    "x": [1, 2, 3],
    "y": [4, 5, 6],
    "옵션": {
        "제목": "매출 변화",
        "x축": {
            "이름": "월",
            "색": "red"
        },
        "y축": {
            "이름": "매출",
            "색": "blue"
        },
        "line": {
            "color": "파랑",
            "linewidth": 3,
            "linestyle": "--",
            "alpha": 0.8
        },
        "marker": {
            "문양": "o",
            "크기": 6,
            "색": "빨강",
            "테두리 색": "검정"
        },
        "출력": {
            "그래프 크기": [8, 6],
            "해상도": 150,
            "파일로 저장": "sales.png"
        }
    }
}
```

## 5. GUI 기획 및 구성 논의

### 1) 기획 목표
NoR 프로젝트의 GUI는 DSL을 직접 작성하고, 시각적 결과를 실시간으로 확인할 수 있는 인터랙티브 실행기를 지향한다. 사용자는 복잡한 설정 없이 간단한 명령어 입력만으로 그래프를 그릴 수 있어야 하며, 실행, 결과 확인, 오류 디버깅까지 코드 작성 없이 시각적으로 가능한 환경을 제공하는 것을 목표로 한다.

### 2) 핵심 구성 요소
NoR GUI는 좌측 입력창, 우측 그래프 출력, 하단 로그 영역, 상단 제어 패널로 구성된 2단 구조의 실행기 레이아웃으로 설계되었다.

| 위치 | 구성 요소 | 설명 |
|------|-----------|------|
| 좌측 상단 | NoR 로고 | 클릭 시 초기 화면(Home)으로 이동 |
| 좌측 패널 | 명령어 입력창 (Monaco Editor) | DSL 입력용 에디터, 다크모드 대응, 구문 하이라이팅 포함 예정 |
| 하단 패널 | 로그/에러 출력 창 | 파서 결과, 에러 메시지, 상태 로그 등을 출력 |
| 우측 상단 | 실행 버튼 (▶︎) | DSL 실행, 단축키 Cmd/Ctrl + Enter와 연동 |
| 우측 메인 | 그래프 출력창 (Canvas) | matplotlib 기반 렌더링 이미지 결과를 출력하는 캔버스 |

### 3) 버튼 기능 요약

| 버튼 이름 | 기능 설명 |
|-----------|-----------|
| Run | 현재 입력된 DSL을 실행하여 그래프 생성 |
| Reset | DSL 입력창 초기화 |
| New | 새 탭 또는 새 실행 환경 생성 |
| Samples | 샘플 DSL 템플릿을 불러와 학습 또는 테스트 용도로 사용 가능 |
| Theme | 다크모드 ↔ 라이트모드 전환 |
| 파일명 표시 | 현재 작업 중인 DSL 스크립트의 이름 또는 상태를 화면 상단에 표시 |

### 4) 추가 고려 요소

#### (1) 로딩 및 애니메이션 효과
- DSL 실행 시 로딩 스피너 또는 그래프 페이드 인 애니메이션 적용
- 초기 화면 진입 시 간단한 인트로 효과 (예: 로고 등장 애니메이션) 구성

#### (2) 예외 및 에러 처리 UX
- DSL 문법 오류 발생 시 하단 로그 창에 빨간색 텍스트로 오류 메시지를 출력
- 에러 라인이 에디터 상에서 하이라이팅되어 직관적인 디버깅이 가능
- 실행 성공 시 "그래프가 성공적으로 생성되었습니다"와 같은 안내 메시지를 표시

#### (3) 편의 기능
- Cmd + Enter 또는 Ctrl + Enter 단축키로 빠른 실행 지원
- DSL 명령어 자동완성 기능 (추후 적용 예정)
- 명령어 색상 구분 및 하이라이팅 (Monaco Editor 구문 강조 기능 활용)

### 5) GUI 예시 화면 구성
Figma로 제작한 와이어프레임을 기준으로 다음과 같은 화면 구성이 기획되었다:

- **Main 실행기 화면**: 좌측에는 DSL 입력창, 우측에는 실행 결과 그래프가 출력되는 구조
- **실행 성공 예시**: "샘플 그래프"가 출력되며, 하단 로그 창에는 "파싱 완료 → 실행 완료" 메시지가 연속적으로 출력
- **실행 실패 예시**: DSL 문법 오류 발생 시 하단 로그에 오류 메시지가 출력되며, 에디터 상에서 해당 라인이 하이라이트
- **다크모드 / 라이트모드**: TailwindCSS 기반 토글을 통해 사용자 인터페이스 전체가 어두운 테마 또는 밝은 테마로 전환

### 6) 사용 기술 스택

| 영역 | 사용 기술 | 설명 |
|------|-----------|------|
| Frontend | React, TailwindCSS | 컴포넌트 기반 프론트엔드 구조, 유틸리티 중심 CSS 구성 |
| UI Library | Ant Design, Framer Motion | 기본 컴포넌트 사용, 애니메이션 효과 구성 |
| Editor | Monaco Editor | VS Code 기반 고급 코드 편집기 |
| Graph | matplotlib | Python Backend에서 그래프 생성, 이미지 형태로 전달 |
| 상태 관리 | Zustand/Redux | 추후 확정 예정, framer-motion으로 인터랙션 강화 예정 |

## 6. 구현 기록 및 논의 사항

### 1) 구현 중 발생한 이슈 및 해결 과정

#### 1. Lark 벡터 구문 오류
Lark에서 벡터를 다음과 같이 정의했을 때 줄바꿈(_NL) 처리와 관련된 파싱 오류가 발생하였다.
```
vector: "[" [element ("," element)*] "]"
```

오류 메시지:
```
lark.exceptions.UnexpectedToken: Unexpected token
Token('_NL', '\n\n')
Expected one of: * _RBRA
```

이는 빈 리스트와 값이 있는 리스트를 Lark가 동일하게 처리하여 생긴 문제였다. 이를 해결하기 위해 빈 벡터와 비어 있지 않은 벡터를 구분하여 다음과 같이 정의하였다.
```
vector: empty_vector | non_empty_vector
empty_vector: "[" "]"
non_empty_vector: "[" elements "]"
elements: element ("," element)*
```

#### 2. 색상 한글 입력 처리
사용자가 "빨강", "파랑" 등 한글로 색상을 입력할 수 있도록 하고, 이를 내부적으로 HEX 코드로 자동 변환하는 로직을 구현하였다. 변환은 convert_color() 함수를 통해 처리되며, 예를 들어 "파랑"은 "#1F77B4"로 매핑되었다.
```python
convert_color("파랑") → "#1F77B4"
```

#### 3. 선굵기 및 마커 크기 동시 매핑
DSL에서 "굵기는 3"과 같은 간단한 명령어로 선의 굵기와 마커의 크기를 동시에 조정할 수 있도록 설계하였다. 내부적으로는 다음과 같은 매핑 테이블을 사용하여 자동 해석이 이루어진다.
```
3 → linewidth: 3, markersize: 6
```

#### 4. 스타일 프리셋 적용
"스타일은 논문용"과 같은 DSL 명령어 하나로 전체 그래프 스타일을 일괄 설정할 수 있도록 구현하였다. 해당 프리셋은 style_config.py에 딕셔너리 형태로 사전 정의되어 있으며, 폰트, 배경색, 선 색상, 해상도 등이 포함되어 있다. 향후에는 사용자 정의 스타일을 .norstyle 파일 등으로 저장하고 다시 불러올 수 있는 기능도 도입할 예정이다.

### 2) 향후 개선 및 보완 과제

| 개선 항목 | 설명 |
|-----------|------|
| CSV 불러오기 | 외부 CSV 파일을 통해 x, y 데이터를 자동으로 불러오도록 지원 |
| 명령어 자동완성 | Monaco Editor 확장을 통해 DSL 키워드 자동완성 기능 제공 |
| 에러 메시지 개선 | 오류 메시지를 보다 구체적이고 친절한 한국어 문장으로 구성 |
| 마커/선 스타일 다양화 | 사용자가 직접 마커 모양, 선 종류 등을 지정할 수 있도록 옵션 확장 |
| 사용자 정의 스타일 저장 | .norstyle 파일 형식 등으로 스타일 설정을 저장하고 불러오는 기능 도입 |
| GUI 반응형 개선 | 아직 부족한 GUI를 완성시키고 반응형으로 제작 |

### 3) 회의 요약 (2025.05.16 기준)

| 시간 | 내용 |
|------|------|
| 오후 4시 | 온라인 회의 진행 (참여자: 최현경, 류지성, 이운길) |
| 핵심 안건 | DSL 문법 설계 구체화, 명령어 구조 정리, 추상화 수준 결정, GUI 실행기 기본 구성 논의 |
| 회의 결정 | 한글 기반 DSL 문법 체계를 유지하기로 함 |

이러한 내용을 바탕으로 진행하던 작업을 계속하기로 하였으며 일주일 뒤에 회의 계획을 설정하였다. 